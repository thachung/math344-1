<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="hiddenproof"><h4 class="heading"><span class="title">Proof (following P. Chernoff).</span></h4> <div class="para">We show that any net <span class="process-math">\((f_i)_{i\in I}\)</span> in <span class="process-math">\(X\)</span> has a limit point <span class="process-math">\(f\in X\text{.}\)</span> In an effort to distinguish between the different types of tuple objects at play here, I will exclusively use tuple notation for nets and exclusively use function notation for elements of <span class="process-math">\(X=\prod_{t\in T}X_t\text{.}\)</span> This is already in force above: the net <span class="process-math">\((f_i)_{i\in I}\)</span> specifies an element <span class="process-math">\(f_i\in X\)</span> for each index <span class="process-math">\(i\in I\text{;}\)</span> but each <span class="process-math">\(f_i\)</span> is itself a function <span class="process-math">\(f_i\colon T\rightarrow \bigcup_{t\in T}X_t\)</span> satisfying <span class="process-math">\(f(t)\in X_t\text{.}\)</span>
</div> <div class="para">Now define <span class="process-math">\(\mathcal{F}\)</span> to be the set of all pairs <span class="process-math">\((S,g)\text{,}\)</span> where <span class="process-math">\(S\subseteq T\)</span> and <span class="process-math">\(g\in X_S=\prod_{t\in S}X_t\)</span> is a limit point of the net <span class="process-math">\((f_i\vert_S)_{i\in I}\text{.}\)</span> Note how we are exploiting the function notation here: since elements of <span class="process-math">\(X_S\)</span> are just functions with domain <span class="process-math">\(S\subseteq T\text{,}\)</span> restricting the domain yields a map from <span class="process-math">\(X\)</span> to <span class="process-math">\(X_S\)</span> defined as <span class="process-math">\(f\mapsto f\vert_S\text{.}\)</span> This map is in fact just the projection map <span class="process-math">\(\pi_S\colon X\rightarrow \prod_{t\in S}X_t\)</span> defined as <span class="process-math">\(\pi_S(f)=(\pi_t(f))_{t\in S}\text{.}\)</span> It follows from this that this map is continuous.</div> <div class="para">Next, we define the relation <span class="process-math">\(\leq\)</span> on <span class="process-math">\(\mathcal{F}\)</span> as follows: <span class="process-math">\((S,g)\leq (S', g')\)</span> if and only if <span class="process-math">\(S\subseteq S'\)</span> and <span class="process-math">\(g'\vert_{S}=g\text{.}\)</span> It is easy to see that <span class="process-math">\(\leq\)</span> is a partial ordering. We now proceed in two steps: (1) we will show that <span class="process-math">\(\mathcal{F}\)</span> satisfies the conditions of Zorn's lemma, and hence that it has a maximal element <span class="process-math">\((S^*, g^*)\text{;}\)</span> (2) we will show that <span class="process-math">\(S^*=T\)</span> and hence that <span class="process-math">\(g^*=f\in X\)</span> is a limit point of <span class="process-math">\((f_i)_{i\in I}\text{.}\)</span> It then follows that <span class="process-math">\(X\)</span> is compact, as desired.</div> <article class="hiddenproof"><a href="" class="proof-knowl original" data-knowl="./knowl/proof-87-hidden.html" title="Proof 1.25.6.1.1: Step 1: \mathcal{F} has a maximal element"><h5 class="heading"><span class="title">Step 1: <span class="process-math">\(\mathcal{F}\)</span> has a maximal element.</span></h5></a></article></article><span class="incontext"><a href="s_Tychonoff.html#proof-86" class="internal">in-context</a></span>
</body>
</html>
